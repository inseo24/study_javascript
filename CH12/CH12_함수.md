함수 : 일련의 과정을 문(statement)으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것. Function 객체

- 매개변수(parameter), 인수(argument), 반환값(return value)

인수를 매개변수를 통해 함수에 전달 → 함수 실행(=함수 호출) → 값 반환

​

Function Definition

​

함수 사용 이유

- 코드 재사용

- 유지보수 편의성 증가(중복 억제)

- 코드 신뢰성 증가

- 객체 타입으로 식별자를 붙이기 때문에, 잘 작성하면 코드 가독성 향상 가능

​

​

12.4 함수 정의

변수는 선언, 함수는 정의한다는 표현을 사용

​

정의 방식

- 함수 선언문

- 함수 표현식 - 함수 리터럴

함수 선언문과 함수 표현식의 차이는 이름 생략 가능 여부, 표현식인 문인지 여부, 호이스팅되는지 여부

- Function 생성자 함수(new)

- 화살표 함수(ES6)

​

​

함수 선언문
```jsx
function add(x,y){
	return x + y;
}
```
​

함수 리터럴 : 변수에 함수 리터럴을 할당 가능(객체)

보통 일반 객체는 호출할 수 없으나, 함수는 호출 가능.

** 일반적으로 함수 리터럴은 이름을 생략한 익명 함수로 많이 씀

→ 특이한 사항 하나가, 기명 함수 리터럴이 자바스크립트 엔진에서 함수 선언문으로 해석되는 경우가 있음.

→ 함수 선언문은 표현식이 아닌 문이기 때문에 변수에 할당할 수 없으나 위의 예제를 보면 할당되는 것처럼 보이는 이유가 이것.

​

​

- 선언문이나 리터럴이나 함수 생성은 동일하나 내부 동작에 차이가 있음

선언문으로 생성된 함수는 호출 가능, 리터럴 표현식으로 생성된 함수는 호출 불가

리터럴로 생성한 함수는 함수 몸체 내에서만 참조할 수 있는 식별자이므로 외부에서 호출 불가. 즉, 함수를 가리키는 식별자가 없음

​

- 함수 선언문으로 함수를 생성하면 자바스크립트 엔진이 이걸 해석하는 과정에서 함수 객체를 생성함.

- 이 때 함수 이름은 내부에서만 사용가능한 식별자이므로 별도로 함수 객체를 가리키는 식별자가 필요함

- 자바스크립트 엔진이 함수 호출을 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성함

​

​

예를 들어, 함수 선언문으로 정의된 함수를 자바스크립트 엔진은 다음과 같이 변경한다.
```jsx
function multi(x, y){
 return x * y;
};

// 아래와 같이 함수 표현식의 형태로 변경된다.

var multi = function multi(x, y){
 return x * y;
};
```

함수 이름으로 함수가 호출되는 것처럼 보이지만, 실제로는 var multi의 변수로 함수 외부에서 호출되는 구조다.

→ 함수명은 함수 몸체에서 자신을 재귀적 호출을 하거나 자바스크립트 디버거가 해당 함수를 구분할 수 있는 식별자의 역할을 한다.

→ 즉, 함수는 함수 이름이 아닌 함수를 가리키는 식별자로 호출됨

→ 함수를 가리키고 있는 레퍼런스

​

​

- 자바스크립트에서 함수는 객체!

primitive 같은 경우 메모리에 value가 그대로 저장되나, 객체의 경우 메모리에 레퍼런스(ref)가 저장됨

​

함수는 다른 객체처럼 속성 및 메서드를 가질 수 있는 일급(first-class) 객체라고 표현하는데,

일급 객체란 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체를 가리킴. 변수나 객체, 배열 등에 저장할 수 있고 다른 함수에 전달되는 인수로도 사용할 수 있으며 함수의 반환값이 될 수도 있다.

​

즉, 함수를 값처럼 자유롭게 사용 가능함을 의미.

​

​

특징

- 무명(anonymous)의 리터럴로 표현이 가능하다.

- 변수나 자료구조(객체, 배열...)에 저장할 수 있다.

- 함수의 파라미터로 전달할 수 있다.

- 반환값(return value)으로 사용할 수 있다.

→ 이런 특징으로 함수 리터럴 방식으로 함수를 정의하고 변수에 할당할 수 있는데 이런 방식을 함수 표현식(Function expression)이라고 한다.

```jsx
// 함수 표현식
var square = function(number) {
  return number * number;
};

// 기명 함수 표현식(named function expression)
var foo = function multiply(a, b) {
  return a * b;
};

// 익명 함수 표현식(anonymous function expression)
var bar = function(a, b) {
  return a * b;
};

console.log(foo(10, 5)); // 50
console.log(multiply(10, 5)); // Uncaught ReferenceError: multiply is not defined
```

변수에 할당 시, 이 변수는 함수명이 아니라 할당된 함수를 가리키는 참조값을 저장하게 된다. 함수 호출 시 함수명이 아니라 함수를 가리키는 변수명을 사용하면 된다.

 

```jsx
var foo = function(a, b) {
  return a * b;
};

var bar = foo;

console.log(foo(10, 10)); // 100
console.log(bar(10, 10)); // 100
```

여기서 변수 bar와 foo는 동일한 익명 함수의 참조값을 갖는다.

​

​

함수가 할당된 변수를 사용해 함수를 호출하지 않고 기명 함수의 함수명을 사용해 호출하게 되면 에러가 발생한다. 이는 함수 표현식에서 사용한 함수명은 외부 코드에서 접근 불가능하기 때문이다. (실질적으로는 함수 선언문의 경우도 마찬가지)

​

- 표현식과 달리 선언문은 호이스팅이 된다 → 즉, 선언문 이전에 호출 할 수 있는데,

→ 함수의 생성 시점이 다르기 때문!

​

- 함수 선언문으로 함수를 정의하면 런타임 이전에 함수 객체가 먼저 생성되고,

- 자바스크립트 엔진이 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성해 생성된 함수 객체를 할당함

→ 런타임에는 이미 함수 객체가 생성되어 있고 함수 이름과 동일한 식별자에 할당까지 완료가 된 상태.

​

​

→ 변수 호이스팅과 다른 점은 var 키워드로 생성된 변수는 undefined로 초기화되고, 함수 선언문을 통해 암묵적으로 생성된 식별자는 함수 객체로 초기화된다.

→ 함수 작성 전에 함수를 호출했지만, 코드는 동작함!

​

​

```jsx
catName("Chloe");

function catName(name) {
  console.log("My cat's name is " + name);
}
/*
위 코드의 결과는: "My cat's name is Chloe"
*/

var x = 1; // x 초기화
console.log(x + " " + y); // '1 undefined'
var y = 2;

// 아래 코드는 이전 코드와 같은 방식으로 동작합니다.
var x = 1; // Initialize x
var y; // Declare y
console.log(x + " " + y); // '1 undefined'
y = 2; // Initialize y
```

- 함수 표현식은 변수에 할당되는 값이 함수 리터럴인 문이기 때문에 변수 선언문과 변수 할당문을 한 번에 기술한 축약 표현과 동일하게 동작

​

​

변수 할당문의 값은 할당문이 실행되는 시점인 런타임에 평가되기 때문에, 함수 표현식의 함수 리터럴도 할당문이 실행되는 시점에 평가되어 함수 객체가 된다.

함수 표현식으로 함수를 정의하면 함수 호이스팅이 아닌 변수 호이스팅이 발생함.

​

함수 표현식 이전에 함수를 참조하면 undefined로 평가되어 이 때 호출하면 TypeError 가 발생. 따라서 함수 표현식으로 정의한 함수는 반드시 함수 표현식 이후에 참조 또는 호출해야 함.

​

​

Function 생성자 함수

new 연산자와 함께 호출하면 함수 객체를 생성해 반환
> var add = new Function('x','y', 'return x + y');
console.log(add(2,6))
8
>

함수 선언문이나 표현식으로 생성한 함수와 다르게 동작하고, 클로저를 생성하지 않는 등의 이유로 사용을 권하지 않음. 클로저는 아직 다루지 않은 내용이니 넘어가고, 기존 2가지 방식과 동일하게 동작하지 않는다는 것을 주목.

​

​

화살표 함수

ES6 도입, 더 간략하게 사용. 항상 익명 함수로 정의

 

```jsx
function add(x,y){
	return x + y;
}

const add = (x, y) => x + y;
console.log(add(2,5)); // 7
```

생성자 함수로 사용 불가, 기존 함수와 this 바인딩 방식이 다르고 prototype 프로퍼티가 없으며 arguments 객체를 생성하지 않음. 자세한 내용은 26.3절 참조

​

​

12.5 함수 호출

매개변수(parameter) : 함수에 들어오는 값

인수(argument) : 함수로 넘기는 값

​
```jsx
function add(x, y){...} 
// x, y는 매개변수
// 해당 함수에 일을 시킬 때, 
add(3,5)
// 라고 하면 3,5과 인수
```

​

- 매개변수는 함수 몸체 내부에서만 참조할 수 있고, 외부에서는 참조할 수 없음 → 스코프가 함수 내부임

- 매개변수와 인수 개수가 일치하는지 체크하지 않음 → 그냥 부족하면 undefined 값

- 매개변수보다 인수가 더 많으면 초과된 인수는 무시됨 → 버려지는 것은 아니고, 모든 인수는 암묵적으로 arguments 객체의 프로퍼티로 보관됨

- arguments 객체는 함수 정의 시 매개변수 개수를 확정할 수 없는 가변 인자 함수를 구현할 때 유용 → 관련 내용은 18.2.1절을 참고

​

→ 자바스크립트는 타입스크립트와 달리 함수 명세를 봤을 때 매개변수가 어떤 값인지 지정할 수가 없음 → 따라서 보통 타입을 확인하는 코드를 작성하는 경우가 많음

​

예를 들어, 타입스크립트라면 아래와 같이 작성되어 여기 들어가는 타입을 유추할 수 있으나,

```jsx
function add(a: number, b: number) {
	const sum = a + b;
}
```

자바스크립트는 그렇지 않기 때문에, 아래와 같이 검증하는 코드를 작성하거나, 아니면 인수 전달이 안되면 경우 매개변수에 기본값을 넣기도 함.

​

책에서는 기본값을 넣는 방법으로 아래와 같이 단축 평가를 사욯한 방법을 제시했으나,

​

ES2015부터 아래처럼 head에 기본값 설정이 가능해짐

 
```jsx
function multiply(a, b = 1) {
  return a*b
}

multiply(5, 2)          // 10
multiply(5)             // 5
multiply(5, undefined)  // 5
```

** 매개변수의 개수는 가독성, 유지보수성 측면에서 최대한 적게 사용하는게 좋음

** 이상적인 함수는 한 가지 일만 해야 하고 가급적 작게 만들어야 한다.

​

​

12.6 참조에 의한 전달과 외부 상태의 변경

함수 호출하면서 매개변수에 값을 전달할 때,

원시 타입을 전달 받는지, 객체를 전달받는지에 따라 발생하는 차이.

​

→ primitive의 경우, immutable value이기 때문에 직접 변경 불가, 재할당을 통해 할당된 원시 값을 새로운 원시 값으로 교체(기존 원본은 보존됨, 부수 효과 발생하지 않음)

​

→ 객체 타입 인수의 경우, mutable value이기 때문에 직접 변경할 수 있고 재할당 없이 직접 할당된 객체를 변경함(원본이 훼손, 부수 효과 발생)

​

발생 이유는 객체가 변경할 수 있는 값이고, 참조로 전달하는 방식으로 동작하기 때문에 발생하는 것.

여러 변수가 참조 값을 공유하고 있다면 이 변수들은 언제든지 참조하고 있는 객체를 직접 변경할 수 있음 → 의도치 않은 객체 변경이 일어날 수 있기 때문에

→ 객체의 변경을 추적하려면 옵저버 패턴 등을 통해 참조를 공유하는 모든 이들에게 변경 사실을 통지하고 이에 대처하는 추가 대응이 필요.

→ 다른 문제 해결 방법으로 객체를 불변 객체로 만들어 사용하는 것

→ 객체 상태 변경을 원천봉쇄하고, 상태 변경이 필요할 경우에는 깊은 복사로 새로운 객체를 생성하고 재할당을 통해 교체함

​

이렇게 외부 상태를 변경하지 않고 의존하지 않는 함수를 순수 함수라고 한다.

- 순수 함수(pure function) : 외부 상태에 의존, 변경하지 않음 → 부수효과가 없음

- 비순수 함수(impure function) : 외부 상태에 의존하거나 변경하는 함수 → 부수효과 有

​

순수 함수는 매개변수를 통해 함수 내부로 전달된 인수에게만 의존해 반화값을 만든다. 즉, 동일 인수가 전달되면 동일한 값을 반환

```jsx
var count = 0;

// 순수 함수 increase는 동일한 인수가 전달되면 항상 동일한 값을 반환함
function increase(n) {
	return ++n;
}

// 순수 함수가 반환한 결과값을 변수에 재할당해서 상태를 변경
count = increase(count);
console.log(count); // 1

count = increase(count);
console.log(count); // 2

// 함수 increase는 매개변수 n을 통해 외부에서 숫자값을 전달받음
// count라는 매개변수를 통해 함수를 호출을 하면,
// count가 담고 있는 원시값이 복사되어 n으로 전달됨
// 전달이 된 후에 외부의 count와 n이 갖고 있는 숫자값은 별개의 값이 됨 
// increase 함수 내에서 n을 증가시키고 재할당하는 효과

// 즉, 외부 상태를 전달받기는 하나 그 외부 상태에는 어떤 영향도 주지 않음. 
// 값을 결국 재할당
```

비순수 함수는 외부 상태에 따라 반환값이 달라진다.

 
```jsx
var count = 0; // 현재 카운트를 나타내는 상태로 increase 함수에 의해 변화

// 비순수 함수
function increase() {
	return ++count; // 외부 상태에 의존하고 외부 상태를 변경(count를 직접 변경함)
}

// 비순수 함수는 외부 상태(count)를 변경하므로 상태 변화를 추적하기 어려워짐
increase();
console.log(count); // 1

increase();
console.log(count); // 2

// 호출할 때마다, 반환값이 변경될 수 있는데
// 순수함수는 동일값이 보장되는데, 비순수함수는 동일값을 보장되지 않음
// 외부 상태에 의존하고 있기 때문.
```

순수함수는 단순하고 예측이 쉬움.

함수형 프로그래밍에서는 순수 함수를 통해 부수 효과를 억제해 프로그램 안정성을 높임.

​

​

12.7 다양한 함수의 형태

즉시 실행 함수(IIFE) - 보통 익명 함수 사용, () 그룹 연산자로 감쌈

 

```jsx
(function () {
	var a = 3;
	var b = 5;
	return a * b;
}());
```

재귀 함수(Recursive call) - 자기 자신을 호출

보통 반복되는 처리를 위해 사용, 팩토리얼 등

결과가 무한히 반복되기 때문에 종료를 위해 종료 조건을 넣음.

 
```jsx
// 팩토리얼
// 재귀적 호출
function factorial(n) {
  if (n < 2) return 1;
  return factorial(n - 1) * n;
}

console.log(factorial(0)); // 1
console.log(factorial(1)); // 1
console.log(factorial(2)); // 2
console.log(factorial(3)); // 6
console.log(factorial(4)); // 24
console.log(factorial(5)); // 120
console.log(factorial(6)); // 720
```

재귀 함수는 반복 연산을 간단히 구현할 수 있다는 장점이 있지만 무한 반복에 빠질 수 있고, stackoverflow 에러를 발생시킬 수 있으므로 주의하여야 한다.

대부분의 재귀 함수는 for나 while 문으로 구현이 가능하다. 반복문보다 재귀 함수를 통해 보다 직관적으로 이해하기 쉬운 구현이 가능한 경우에만 한정적으로 적용하는 것이 바람직하다.

​

​

- 콜백함수(Callback function)

함수에서 반복하는 일은 변하지 않고 공통적으로 수행하나 그 내용이 다를 경우 → 일부분이 다를 경우 매번 함수를 새롭게 정의해야 함 → 함수 합성으로 문제 해결

함수의 변하지 않는 공통 로직은 미리 정의해두고, 경우에 따라 변경되는 로직은 추상화해서 함수 외부에서 내부로 전달함.

​

​

​

함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 콜백함수라고 하며, 매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수를 고차함수라고 한다.

​

위의 예시에서 logAll, logOdds 가 콜백함수고 고차함수는 repeat이 된다.

​

이렇게 매개변수로 함수를 받을 수 있는 이유는 함수가 일급 객체이기 때문.

​

콜백함수도 고차 함수에 전달되어 헬퍼 함수의 역할을 한고, 함수 외부에서 고차 함수 내부로 주입하기 때문에 자유롭게 교체할 수 있음.

→ 고차 함수는 콜백 함수를 자신의 일부분으로 합성함

→ 고차 함수는 매개변수를 통해 전달받은 콜백 함수의 호출 시점을 결정해 호출한다.

→ 콜백 함수는 고차 함수에 의해 호출되며, 이때 고차 함수는 필요에 따라 콜백 함수에 인수를 전달할 수 있다.

​

​

콜백 함수가 고차 함수 내부에서만 호출되면 콜백 함수를 익명 함수 리터럴로 정의하고 바로 고차 함수에 전달하는 것이 일반적

```jsx
repeat(5, function(i) {
	if (i % 2) console.log(i);
}); // 1, 3
```

→ 이 때 콜백 함수는 고차 함수가 호출될 때마다 평가되어 함수 객체를 생성함

→ 따라서 다른 곳에서 호출할 필요가 있거나 자주 호출되면 외부에서 정의한 후 참조를 하는게 효율적

```jsx
// logOdds 함수는 한번만 생성됨
var logOdds = function (i) {
	if (i % 2) console.log(i);
};

// 함수 참조 전달
repeat(5, logOdds); // 1 3
```

이 외에 비동기 처리(이벤트 처리, Ajax 통신, 타이머 함수 등)에 많이 활용 됨

대표적인 예로 이벤트 핸들러 처리를 보면 아래와 같다.

​```jsx
<button id="myButton">Click me</button>
  <script>		
		var button = document.getElementById('myButton');
    button.addEventListener('click', function() {
      console.log('button clicked!');
    });
	</script>
```

콜백 함수는 매개변수를 통해 전달되고 전달받은 함수의 내부에서 어느 특정시점에 실행된다. 아래 예시에서 두번째 매개변수에 전달된 시간이 경과되면 첫번째 매개변수에 전달한 콜백 함수가 호출된다.

```jsx
// 콜백 함수를 사용한 비동기 처리
// 1초 후 메시지 출력

setTimeout(function () {
  console.log('1초 후 출력');
}, 1000);
```

콜백 함수는 주로 비동기식 처리 모델에서 사용된다. 비동기식 처리 모델이란 처리가 종료하면 호출될 함수(콜백함수)를 미리 매개변수에 전달하고 처리가 종료하면 콜백함수를 호출하는 것이다. ( 동기식으로 사용되기도 한다.)

​

콜백함수는 콜백 큐에 들어가 있다가 해당 이벤트가 발생하면 호출된다. 콜백 함수는 클로저이므로 콜백 큐에 단독으로 존재하다가 호출되어도 콜백함수를 전달받은 함수의 변수에 접근할 수 있다.